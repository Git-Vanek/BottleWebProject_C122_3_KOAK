% rebase('layout.tpl', title='Floyd algorithm theory', year=year)
<div class="container">
  <h1 class="text-center header-page">Алгоритм Флойда</h1>

  <div class="theory-block">
    <h3>Формальная постановка задачи</h3>
    <p>
      Имеется неориентированный взвешенный граф. Задача алгоритма Флойда заключается в нахождении кратчайших путей между всеми парами вершин в графе.
    </p>
  </div>
  <div class="theory-block">
    <h3>Неформальная постановка задачи</h3>
    <p>
      Давай представим, что у нас есть сеть из узлов, через которые проходит информация. Наша задача — найти кратчайшие пути
      между всеми парами узлов в сети. Входные данные — матрица смежности, где на пересечении строки и столбца указана длина
      пути между соответствующими узлами (если связи между узлами нет, то в ячейке матрицы указывается значение бесконечности 
      или другое большое число).
      Алгоритм Флойда поможет нам найти кратчайшие пути между всеми парами узлов. Он состоит из нескольких шагов,
      в результате которых будет построена матрица кратчайших путей. Итак, наша задача — реализовать алгоритм Флойда и найти
      кратчайшие пути между всеми узлами в сети.
    </p>
  </div>
  <div class="theory-block">
    <h3>Описание алгоритма Флойда</h3>
    <p>
        Алгоритм Флойда, разработанный Робертом Флойдом в 1962 году, является методом поиска кратчайших путей между всеми парами
        вершин во взвешенном графе.
        Он основан на динамическом программировании и заключается в поочередном рассмотрении всех возможных промежуточных вершин
        на пути между каждой парой вершин. 
        Алгоритм Флойда является эффективным способом нахождения всех кратчайших путей в графе и используется в различных областях, 
        таких как транспортная логистика, телекоммуникации и информационные технологии.
    </p>
    <p>
        Алгоритм Флойда заключается в том, чтобы построить матрицу D размером N x N, в которой D[i][j] будет содержать длину
        кратчайшего пути между вершинами i и j. Изначально эта матрица заполняется значениями матрицы смежности.
    </p>
  </div>

  <div class="theory-block">
    <h3>Псевдокод алгоритма Флойда</h3>
    <p>Вход:</p>
    <ol>
      <li>Размерность матрицы n</li>
      <li>Матрица смежности D[i][j]</li>
    </ol> 
    <p>Выход: матрица расстояний между всеми парами вершин W[i][j] </p>
    <p><a data-toggle="collapse" href="#floydpsevdocode" aria-expanded="false" aria-controls="floydpsevdocode">Просмотр псевдокода</a> </p>
    <div class="collapse" id="floydpsevdocode">
        <pre>
            <code id="pseudocode">1.    процедура AlgoFloyda do  // Алгоритм Флойда
                <br>2.   Для каждой вершины k от 1 до n:
                <br>3.        Для каждой вершины i от 1 до n:
                <br>4.            Для каждой вершины j от 1 до n:
                <br>5.                Если W[i][j] > W[i][k] + W[k][j]) do
                <br>6.                    W[i][j] = W[i][k] + W[k][j]
                <br>7.   Вывод получившейся матрицы расстояний между всеми парами вершин W[i][j] в виде графа 
            </code>
        </pre>
    </div>
  </div>

  <div class="theory-block">
    <h3>Разбор конкретного примера</h3>
    <p>
        Применить алгоритм Флойда для нахождения кратчайших путей между вершинами для следующего графа:
    </p>
    <br>
    <figure class="text-center mb-3">
      <img src="/static/images/floyd_condition.png" class="img-fluid" />
      <figcaption class="figure-caption">
        Исходный граф
      </figcaption>
    </figure>
    <br>
    <p>
      1. Выбираем в качестве исходной вершину <code>1</code>, а в качестве промежуточной вершину <code>2</code>
      <br> 2. Теперь проводим путь от исходной вершины <code>1</code> через выбранную промежуточную вершину ко всем остальным. 
      <br> Например: путь 1-2-3. Его суммарный вес будет равен 18 (13 + 5). Так как вес получившегося нового пути больше существующего (18 > 5),
      мы не изменяем текущее расстояние. <br> Проведем путь 1-2-4, вес которого составит 20 (13 + 7). Так как до этого прямого пути от вершины
      <code>1</code> до вершины <code>4</code> не существовало (расстояние между ними было равно бесконечности), то проводим прямой путь 1-4 с найденным весом 20 (20 < ?)
      <br> 3. Меняем промежуточную вершину на следующую и повторяем действие 2. Так необходимо перебрать все вершины в качестве промежуточных. 
      <br> Ниже представлен граф после того, как в роли исходной вершины была взята вершина <code>1</code>:
    </p>
    <br>
    <figure class="text-center mb-3">
      <img src="/static/images/floyd_step_1.png" class="img-fluid" />
      <figcaption class="figure-caption">
        Обновленный граф, после выбора вершины <code>1</code> в качестве исходной
      </figcaption>
    </figure>
    <br>
    <p>Теперь в качестве исходной берем вершину <code>2</code> и проделываем все то же самое. 
    <br> В данном случае, граф никак не был изменен, поскольку ни в одном случае не получилось расстояние между вершинами короче существующего.
    <br> Принимая последовательно все вершины в качестве исходных и выполняя представленные действия в конечном итоге мы получим результативный 
    граф с кратчайшими расстояниями между вершинами:
    </p>
    <br>
    <figure class="text-center mb-3">
      <img src="/static/images/floyd_step_2.png" class="img-fluid" />
      <figcaption class="figure-caption">
        Обновленный граф, после выбора вершины <code>3</code> в качестве исходной      
      </figcaption>
    </figure>
    <br>
    <br>
    <figure class="text-center mb-3">
      <img src="/static/images/floyd_step_3.png" class="img-fluid" />
      <figcaption class="figure-caption">
        Конечный граф с кратчайшими расстояниями между вершинами   
      </figcaption>
    </figure>

  </div>

  <div class="theory-block">
    <h3>Оценка сложности</h3>
    <p>
        Сложность метода Флойда составляет O(V^3), где V - количество вершин в графе. 
        Таким образом, при увеличении числа вершин в графе на 10 раз, время выполнения алгоритма увеличится в 1000 раз.
        Из-за кубической сложности метод Флойда может быть неэффективен для больших графов с большим количеством вершин. 
    </p>
    <p>
        В таких случаях рекомендуется использовать более оптимизированные алгоритмы, такие как Алгоритм Дейкстры
        или Алгоритм Беллмана-Форда, которые имеют сложность O(V^2) и O(VE) соответственно.
    </p>
  </div>

  <div class="theory-block text-center">
    <h3>Попробуйте сами!</h3>
    <p>
      Если вы хотите протестировать алгоритм Флойда на своем примере,
      воспользуйтесь нашим калькулятором:
    </p>

    <a id="floyd-calc-button" href="/prima_algorithm_calc" class="btn btn-primary">Открыть калькулятор</a>
  </div>
</div>