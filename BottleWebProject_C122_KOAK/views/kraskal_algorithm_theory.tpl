% rebase('layout.tpl', title='Prima algorithm theory', year=year)
<div class="container">
  <h1 class="text-center header-page">Алгоритм Краскала</h1>

  <div class="theory-block">
    <h3>Формальная постановка задачи</h3>
    <p>
      Имеется следующий неориентированный взвешенный граф. 
      Назовем остовным деревом подграф, содержащий все вершины 
      исходного графа, который является деревом. И задача состоит в том, 
      чтобы найти такое остовное дерево, сумма рёбер которого минимальна.
    </p>
  </div>
  <div class="theory-block">
    <h3>Неформальная постановка задачи</h3>
    <p>
      Представьте исходный граф без рёбер, теперь вам нужно как-то соединить 
      все вершины между собой, чтобы можно было бы попасть из любой вершины в 
      другую, не имея при этом циклов в получившемся графе с минимально возможной 
      суммой весов включенных рёбер.
    </p>
  </div>
  <div class="theory-block">
    <h3>Описание алгоритма</h3>
    <p>
      Механизм, по которому работает данный алгоритм, очень прост. На входе 
      имеется пустой подграф, который и будем достраивать до потенциального 
      минимального остовного дерева. Будем рассматривать только связные графы, 
      в другом случае при применении алгоритма Краскала мы будем получать не 
      минимальное остовное дерево, а просто остовной лес.
    </p>
    <ul>
      <li>
        Вначале мы производим сортировку рёбер по неубыванию по их весам.
      </li>
      <li>
        Добавляем i-ое ребро в наш подграф только в том случае, если данное ребро 
        соединяет две разные компоненты связности, одним из которых является наш 
        подграф. То есть, на каждом шаге добавляется минимальное по весу ребро, 
        один конец которого содержится в нашем подграфе, а другой - еще нет.
      </li>
      <li>
        Алгоритм завершит свою работу после того, как множество вершин нашего 
        подграфа совпадет с множеством вершин исходного графа.
      </li>
    </ul>
    <p>
        Данный алгоритм называется жадным из-за того, что мы на каждом шаге пытаемся 
        найти оптимальный вариант, который приведет к оптимальному решению в целом.
    </p>
  </div>

  <div class="theory-block">
    <h3>Псевдокод алгоритма Краскала</h3>
    <p>Вход:</p>
    <ol>
      <li>Размерность матрицы n</li>
      <li>Матрица смежности cost[i][j]</li>
      <li>
        Связный взвешенный граф G = (V, E, c): заданный матрицей весов cost[i][j]
      </li>
    </ol>
    <p>Выход: вес min cost минимального остовного дерева графа G</p>
    <p><a data-toggle="collapse" href="#kraskalpsevdocode" aria-expanded="false" aria-controls="kraskalpsevdocode">Просмотр псевдокода</a> </p>
    <div class="collapse" id="kraskalpsevdocode">
         <pre>
            <code id="pseudocode">1.    процедура AlgoKrys do  // Алгоритм Кроскала
                <br>2.    N=1;  //Нчальная вершина
                <br>3.    до тех пор пока(N < n) do  // N - номер текущей вершины
                <br>4.    min=INF;  //Присваивание значения бесконечности min
                <br>5.        пока(i=1; min <= n; i++)  // Проход по 
                <br>6.            пока(j=1; j <= n; j++) // -матрице смежности
                <br>7.                если(cost[i][j] != INF && cost[i][j] != -1) do  // изменить кайму: для чего
                <br>8.                целое mincost=0;  //Введение переменной веса МОД
                <br>9.                    пока(p=1; p<=n; p++) do   
                <br>10.                        если(visited[p]==i || visited[p]==j) count++;
                <br>11.                       end;
                <br>12.                   если(count>=2) do
                <br>13.                       пока(p=1; p<=n; p++)    
                <br>14.                           если(cost[i][j]!=INF && p!=j) dup1=p;
                <br>15.                       пока(p=1;p<=n;p++)  //Добавление ребер шрафа в МОД
                <br>16.                           если(cost[i][j]!=INF && p!=i) dup2=p;
                <br>17.                       если(cost[dup1][dup2]==-1) end;
                <br>18.                   l=i; k=j; v=cost[i][j]; end;  //Связь ребер в МОД
                <br>19.               Вывод на экран << "Ребро" << l << "-->" << k;
                <br>20.               cost[l][k]=-1; cost[k][l]=-1; visi++;
                <br>21.               пока(j=l; i<=n; i++) do
                <br>22.                   если(visited[i]==l) count++;
                <br>23.                   если(visited[j]==k) count++; end;
                <br>24.               если(count==0) visited[++vst]=l;
                <br>25.               если(count==0) visited[++vst]=k;
                <br>26.    end;
            </code>
        </pre>
    </div>

  </div>

  <div class="theory-block">
    <h3>Разбор конкретного примера</h3>
    <p>
        Применить алгоритм Краскала для нахождения минимального остовного дерева следующего графа:
    </p>
    <figure class="text-center mb-3">
      <img src="/static/images/prima_and_kraskal_condition.png" class="img-fluid" />
      <figcaption class="figure-caption">
        Исходный граф
      </figcaption>
    </figure>
    <p>
      Из представленного сверху графа, выпишем все его ребра в отсортированном порядке:
    </p>
    <code>
      1) D <--> B; w = 2
      <br>2) D <--> C; w = 6
      <br>3) A <--> B; w = 7
      <br>4) A <--> C; w = 8
      <br>5) C <--> E; w = 9
      <br>6) D <--> F; w = 9
      <br>7) F <--> E; w = 10
      <br>8) B <--> C; w = 11
      <br>9) D <--> E; w = 11
    </code>
    <p>
      И начнем по списку добавлять эти ребра в наш остов:
    </p>
    <figure class="text-center mb-3">
      <img src="/static/images/kraskal_step_1.png" class="img-fluid" />
      <figcaption class="figure-caption">
        Подграф после добавиления 1-го ребра
      </figcaption>
    </figure>
    <figure class="text-center mb-3">
      <img src="/static/images/kraskal_step_2.png" class="img-fluid" />
      <figcaption class="figure-caption">
        Подграф после добавления 2-го и 3-го рёбер
      </figcaption>
    </figure>
    <p>
      При добавлении в наше остовное дерево ребра <code>A <--> C</code>, как вы 
      можете заметить, образовывается цикл, поэтому мы просто пропускаем данное ребро.
    </p>
    <p>
      По итогу у нас образовывается следующий подграф, и как вы заметили, мы соединили 
      все вершины ребрами с минимально-возможными весами, а значит, нашли минимальное 
      остовное дерево для нашего исходного графа.
    </p>
    <figure class="text-center mb-3">
      <img src="/static/images/prima_and_kraskal_result.png" class="img-fluid" />
      <figcaption class="figure-caption">
        Минимальный остов
      </figcaption>
    </figure>
    <p>Суммарный вес искомого MST равен 33.</p>
  </div>

  <div class="theory-block">
    <h3>Оценка сложности</h3>
    <p>
      Время работы алгоритма Краскала зависит от способа 
      хранения графа и выбора ребра с наименьшим весом. При использовании 
      массива смежности и простого просмотра всех ребер сложность алгоритма 
      составляет O(n^2), где n - количество вершин графа.
    </p>
    <p>
      При использовании списка смежности и сортировки ребер по весу сложность 
      алгоритма снижается до O(m log m), где m - количество ребер графа. Однако, 
      если использовать динамическое программирование для отслеживания компонент 
      связности, сложность алгоритма может быть снижена до O(m log n), где n - количество вершин графа.
    </p>
  </div>

  <div class="theory-block text-center">
    <h3>Попробуйте сами!</h3>
    <p>
      Если вы хотите протестировать алгоритм Прима на своем примере,
      воспользуйтесь нашим калькулятором:
    </p>
    <a href="/kraskal_algorithm_calc" class="btn btn-primary" id="kraskal-calc-button">Открыть калькулятор</a>
  </div>
</div>
